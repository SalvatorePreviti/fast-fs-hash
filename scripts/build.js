#!/usr/bin/env node

/**
 * Build script for fast-fs-hash.
 *
 * 1. Bundles src/index.ts → dist/index.cjs (CJS, the real bundle) using rolldown.
 * 2. Generates dist/index.mjs — a thin ESM wrapper that re-exports from index.cjs.
 *    This avoids dual module instances when both ESM and CJS are loaded.
 * 3. Generates type declarations via tsc + rollup-plugin-dts.
 *
 * Same pattern as vite-plugin-fuse's build script.
 */

import { exec } from "node:child_process";
import { copyFileSync, mkdirSync, readFileSync, rmSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";
import { promisify } from "node:util";
import { writeBuildHash } from "./build-hash.js";

const execAsync = promisify(exec);

const rootDir = resolve(import.meta.dirname, "..");
const pkgDir = resolve(rootDir, "packages/fast-fs-hash");
const srcDir = resolve(pkgDir, "src");
const distDir = resolve(pkgDir, "dist");

mkdirSync(distDir, { recursive: true });

// ── CJS bundle (primary) ────────────────────────────────────────────────

async function buildCJSBundle() {
  console.time("Building CJS bundle...");
  const { build } = await import("rolldown");

  await build({
    input: resolve(srcDir, "index.ts"),
    external: [/^node:/, /^@fast-fs-hash\//],
    output: {
      file: resolve(distDir, "index.cjs"),
      format: "cjs",
      sourcemap: true,
      comments: { jsdoc: true, annotation: true, legal: true },
    },
    resolve: {
      extensions: [".ts", ".js"],
    },
    platform: "node",
  });

  console.timeEnd("Building CJS bundle...");
}

// ── ESM wrapper (thin re-export from CJS) ────────────────────────────────

/**
 * Parse src/index.ts to extract value (non-type) export names,
 * then generate a thin ESM wrapper that re-exports them from index.cjs.
 */
function generateESMWrapper() {
  console.time("Generating ESM wrapper...");

  const src = readFileSync(resolve(srcDir, "index.ts"), "utf8");
  const valueExports = [];

  // Match `export { Name1, Name2 } from "..."` lines (skip `export type {`)
  for (const match of src.matchAll(/^export\s+\{([^}]+)\}/gm)) {
    const line = match[0];
    if (/^export\s+type\s+\{/.test(line)) {
      continue; // skip type-only exports
    }
    for (const name of match[1].split(",")) {
      const trimmed = name.trim();
      if (trimmed) {
        // Handle `Foo as Bar` — use the exported name (after `as`)
        const parts = trimmed.split(/\s+as\s+/);
        valueExports.push(parts[parts.length - 1].trim());
      }
    }
  }

  if (valueExports.length === 0) {
    throw new Error("No value exports found in index.ts — ESM wrapper generation failed");
  }

  const lines = [
    "// Auto-generated ESM wrapper — re-exports from the CJS bundle to avoid dual instances.",
    "// Do not edit manually; regenerated by scripts/build.js.",
    "",
    'import _cjs_mod from "./index.cjs";',
    "",
    "export const {",
    ...valueExports.map((name) => `  ${name},`),
    "} = _cjs_mod;",
    "",
  ];

  writeFileSync(resolve(distDir, "index.mjs"), lines.join("\n"));
  console.log(`  ESM wrapper exports: ${valueExports.join(", ")}`);
  console.timeEnd("Generating ESM wrapper...");
}

// ── Type declarations ────────────────────────────────────────────────────

async function generateTypeDeclarations() {
  console.time("Generating type declarations...");

  const tmpDir = resolve(pkgDir, "dist-types-tmp");
  rmSync(tmpDir, { recursive: true, force: true });

  try {
    // Step 1: Emit .d.ts via tsc (uses tsconfig.build.json which only includes src/)
    await execAsync(`npx tsc -p ${JSON.stringify(resolve(rootDir, "tsconfig.build.json"))}`, {
      cwd: pkgDir,
    }).catch((err) => {
      const msg = (err.stdout || err.stderr || err.message || "").trim();
      if (msg) {
        console.error(msg);
      }
      throw err;
    });

    // Step 2: Bundle with rollup-plugin-dts
    const { rollup } = await import("rollup");
    const { dts } = await import("rollup-plugin-dts");

    const bundle = await rollup({
      input: resolve(tmpDir, "index.d.ts"),
      plugins: [dts({ respectExternal: true })],
      external: [],
    });
    await bundle.write({ file: resolve(distDir, "index.d.ts"), format: "es" });
    await bundle.close();

    // Step 3: CJS type declaration
    writeFileSync(resolve(distDir, "index.d.cts"), 'export * from "./index.js";\n');
  } finally {
    rmSync(tmpDir, { recursive: true, force: true });
  }

  console.timeEnd("Generating type declarations...");
}

// ── Inject optionalDependencies for publish ─────────────────────────────

function injectOptionalDeps() {
  const pkgJsonPath = resolve(pkgDir, "package.json");
  const pkg = JSON.parse(readFileSync(pkgJsonPath, "utf8"));

  // Only inject if not already present (idempotent)
  if (!pkg.optionalDependencies) {
    const version = pkg.version;
    pkg.optionalDependencies = {
      "@fast-fs-hash/darwin-arm64": version,
      "@fast-fs-hash/darwin-x64": version,
      "@fast-fs-hash/freebsd-x64": version,
      "@fast-fs-hash/linux-arm64-gnu": version,
      "@fast-fs-hash/linux-arm64-musl": version,
      "@fast-fs-hash/linux-x64-gnu": version,
      "@fast-fs-hash/linux-x64-musl": version,
      "@fast-fs-hash/win32-arm64-msvc": version,
      "@fast-fs-hash/win32-x64-msvc": version,
    };
    writeFileSync(pkgJsonPath, JSON.stringify(pkg, null, 2) + "\n");
    console.log("Injected optionalDependencies into package.json (version " + version + ")");
  }
}

// ── Run ──────────────────────────────────────────────────────────────────

console.time("Build completed");
await buildCJSBundle();
generateESMWrapper();
copyFileSync(resolve(srcDir, "xxhash128.wasm"), resolve(distDir, "xxhash128.wasm"));
console.log("Copied xxhash128.wasm to dist/");
copyFileSync(resolve(rootDir, "NOTICES.md"), resolve(pkgDir, "NOTICES.md"));
console.log("Copied NOTICES.md to package dir");
await generateTypeDeclarations();

// Only inject for CI/publish — controlled by env var
if (process.env.INJECT_OPTIONAL_DEPS === "1") {
  injectOptionalDeps();
}

await writeBuildHash();

console.timeEnd("Build completed");
