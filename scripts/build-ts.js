#!/usr/bin/env node

/**
 * Build script for fast-fs-hash.
 *
 * 1. Bundles src/index.ts → dist/index.cjs (CJS, the real bundle) using rolldown.
 * 2. Generates dist/index.mjs — a thin ESM wrapper that re-exports from index.cjs.
 *    This avoids dual module instances when both ESM and CJS are loaded.
 * 3. Generates type declarations via tsc + rollup-plugin-dts.
 *
 * Same pattern as vite-plugin-fuse's build script.
 */

import { exec } from "node:child_process";
import { copyFileSync, mkdirSync, readFileSync, rmSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";
import { promisify } from "node:util";
import { DIST_DIR, elapsed, logInfo, logOk, logTitle, PKG_DIR, ROOT_DIR, SRC_DIR } from "./lib/utils.js";

const execAsync = promisify(exec);

const t0 = performance.now();

mkdirSync(DIST_DIR, { recursive: true });

// ── CJS bundle (primary) ────────────────────────────────────────────────

async function buildCJSBundle() {
  const s = performance.now();
  const { build } = await import("rolldown");

  await build({
    input: resolve(SRC_DIR, "index.ts"),
    external: [/^node:/, /^@fast-fs-hash\//],
    output: {
      file: resolve(DIST_DIR, "index.cjs"),
      format: "cjs",
      sourcemap: true,
      comments: { jsdoc: true, annotation: true, legal: true },
    },
    resolve: {
      extensions: [".ts", ".js"],
    },
    platform: "node",
  });

  logOk(`CJS bundle (${elapsed(s)})`);
}

// ── ESM wrapper (thin re-export from CJS) ────────────────────────────────

/**
 * Parse src/index.ts to extract value (non-type) export names,
 * then generate a thin ESM wrapper that re-exports them from index.cjs.
 */
function generateESMWrapper() {
  const s = performance.now();

  const src = readFileSync(resolve(SRC_DIR, "index.ts"), "utf8");
  const valueExports = [];

  // Match `export { Name1, Name2 } from "..."` lines (skip `export type {`)
  for (const match of src.matchAll(/^export\s+\{([^}]+)\}/gm)) {
    const line = match[0];
    if (/^export\s+type\s+\{/.test(line)) {
      continue; // skip type-only exports
    }
    for (const name of match[1].split(",")) {
      const trimmed = name.trim();
      if (trimmed) {
        // Handle `Foo as Bar` — use the exported name (after `as`)
        const parts = trimmed.split(/\s+as\s+/);
        valueExports.push(parts[parts.length - 1].trim());
      }
    }
  }

  if (valueExports.length === 0) {
    throw new Error("No value exports found in index.ts — ESM wrapper generation failed");
  }

  const lines = [
    "// Auto-generated ESM wrapper — re-exports from the CJS bundle to avoid dual instances.",
    "// Do not edit manually; regenerated by scripts/build-ts.js.",
    "",
    'import _cjs_mod from "./index.cjs";',
    "",
    "export const {",
    ...valueExports.map((name) => `  ${name},`),
    "} = _cjs_mod;",
    "",
  ];

  writeFileSync(resolve(DIST_DIR, "index.mjs"), lines.join("\n"));
  logInfo(`ESM exports: ${valueExports.join(", ")}`);
  logOk(`ESM wrapper (${elapsed(s)})`);
}

// ── Type declarations ────────────────────────────────────────────────────

async function generateTypeDeclarations() {
  const s = performance.now();

  const tmpDir = resolve(PKG_DIR, "dist-types-tmp");
  rmSync(tmpDir, { recursive: true, force: true });

  try {
    // Step 1: Emit .d.ts via tsc (uses tsconfig.build.json which only includes src/)
    await execAsync(`npx tsc -p ${JSON.stringify(resolve(ROOT_DIR, "tsconfig.build.json"))}`, {
      cwd: PKG_DIR,
    }).catch((err) => {
      const msg = (err.stdout || err.stderr || err.message || "").trim();
      if (msg) {
        console.error(msg);
      }
      throw err;
    });

    // Step 2: Bundle with rollup-plugin-dts
    const { rollup } = await import("rollup");
    const { dts } = await import("rollup-plugin-dts");

    const bundle = await rollup({
      input: resolve(tmpDir, "index.d.ts"),
      plugins: [dts({ respectExternal: true })],
      external: [],
    });
    await bundle.write({ file: resolve(DIST_DIR, "index.d.ts"), format: "es" });
    await bundle.close();

    // Step 3: CJS type declaration
    writeFileSync(resolve(DIST_DIR, "index.d.cts"), 'export * from "./index.js";\n');
  } finally {
    rmSync(tmpDir, { recursive: true, force: true });
  }

  logOk(`Type declarations (${elapsed(s)})`);
}

// ── Run ──────────────────────────────────────────────────────────────────

logTitle("Building TypeScript...");
await buildCJSBundle();
generateESMWrapper();
copyFileSync(resolve(SRC_DIR, "xxhash128.wasm"), resolve(DIST_DIR, "xxhash128.wasm"));
logOk("xxhash128.wasm copied");
await generateTypeDeclarations();

logOk(`TS build completed (${elapsed(t0)})`);
